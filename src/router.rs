use std::{
    collections::BTreeMap,
    fs::{self, File},
    io::Write,
    marker::PhantomData,
    path::{Path, PathBuf},
    sync::Arc,
};

use specta::{
    datatype::FunctionResultVariant, internal::detect_duplicate_type_names, DataType, TypeMap,
};
use specta_typescript::{datatype, export_named_datatype, BigIntExportBehavior, Typescript};
// use specta_zod::{BigIntExportBehavior, ExportConfig, export_named_datatype, datatype};

use crate::{
    internal::{Procedure, ProcedureStore},
    Config, ExportError,
};

/// TODO
pub struct Router<TCtx = (), TMeta = ()>
where
    TCtx: 'static,
{
    pub(crate) config: Config,
    pub(crate) queries: ProcedureStore<TCtx>,
    pub(crate) mutations: ProcedureStore<TCtx>,
    pub(crate) subscriptions: ProcedureStore<TCtx>,
    pub(crate) typ_store: TypeMap,
    pub(crate) phantom: PhantomData<TMeta>,
}

// TODO: Move this out of this file
// TODO: Rename??
pub enum ExecKind {
    Query,
    Mutation,
}

impl<TCtx, TMeta> Router<TCtx, TMeta>
where
    TCtx: Send + 'static,
{
    pub fn arced(self) -> Arc<Self> {
        Arc::new(self)
    }

    pub fn typ_store(&self) -> TypeMap {
        self.typ_store.clone()
    }

    // TODO: Drop this API in v1
    pub fn queries(&self) -> &BTreeMap<String, Procedure<TCtx>> {
        &self.queries.store
    }

    pub fn export_ts<TPath: AsRef<Path>>(&self, export_path: TPath) -> Result<(), ExportError> {
        let export_path = PathBuf::from(export_path.as_ref());
        if let Some(export_dir) = export_path.parent() {
            fs::create_dir_all(export_dir)?;
        }
        let mut file = File::create(export_path)?;
        if let Some(header) = &self.config.bindings_header {
            writeln!(file, "{}", header)?;
        }
        writeln!(file, "// This file was generated by [rspc](https://github.com/spacedriveapp/rspc). Do not edit this file manually.")?;

        let config = Typescript::default().bigint(BigIntExportBehavior::BigInt);

        let queries_ts =
            generate_procedures_ts(&config, self.queries.store.iter(), &self.typ_store());
        let mutations_ts =
            generate_procedures_ts(&config, self.mutations.store.iter(), &self.typ_store());
        let subscriptions_ts =
            generate_procedures_ts(&config, self.subscriptions.store.iter(), &self.typ_store());

        // TODO: Specta API
        writeln!(
            file,
            r#"
export type Procedures = {{
    queries: {queries_ts},
    mutations: {mutations_ts},
    subscriptions: {subscriptions_ts}
}};"#
        )?;

        if let Some((name, a, b)) = detect_duplicate_type_names(&self.typ_store)
            .into_iter()
            .by_ref()
            .next()
        {
            return Err(ExportError::TsExportErr(
                specta_typescript::ExportError::DuplicateTypeName(name, a, b),
            ));
        }

        for (_sid, dt) in self.typ_store.iter() {
            writeln!(
                file,
                "\n{}",
                export_named_datatype(&config, dt, &self.typ_store)?
            )?;
        }

        Ok(())
    }
}

// TODO: Move this out into a Specta API
fn generate_procedures_ts<'a, Ctx: 'a>(
    config: &Typescript,
    procedures: impl ExactSizeIterator<Item = (&'a String, &'a Procedure<Ctx>)>,
    type_store: &TypeMap,
) -> String {
    match procedures.len() {
        0 => "never".to_string(),
        _ => procedures
            .map(|(key, operation)| {
                let input = match &operation.ty.input {
                    DataType::Tuple(def)
                        // This condition is met with an empty enum or `()`.
                        if def.elements().is_empty() =>
                    {
                        "never".into()
                    }
                    ty => datatype(config, &FunctionResultVariant::Value(ty.clone()), type_store)
                        .expect("Failed to generate TypeScript type for procedure input"),
                };
                let result_ts = datatype(
                    config,
                    &FunctionResultVariant::Value(operation.ty.result.clone()),
                    type_store,
                )
                .expect("Failed to generate TypeScript type for procedure result");

                // TODO: Specta API
                format!(
                    r#"
        {{ key: "{key}", input: {input}, result: {result_ts} }}"#
                )
            })
            .collect::<Vec<_>>()
            .join(" | "),
    }
}
